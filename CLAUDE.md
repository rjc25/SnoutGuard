# Architecture

> Generated by [SnoutGuard](https://github.com/rjc25/SnoutGuard)

## Monorepo Structure

The codebase is a pnpm monorepo with 11 packages under `packages/`, each a bounded domain:

- **core** — Shared types, DB, LLM client, auth, git, logging, config. Foundation layer.
- **analyzer** — Codebase scanning, dependency analysis, pattern detection, decision extraction.
- **reviewer** — Dual-pass code review (deterministic rules + LLM), multi-format output.
- **velocity** — Developer metrics, composite scoring, blocker detection.
- **work-summary** — Template-based LLM summary generation (standup, sprint, 1:1, progress).
- **context-sync** — AI assistant context file generation (7+ formats).
- **integrations** — GitHub, Bitbucket, Slack adapters.
- **mcp-server** — Model Context Protocol server for AI agents.
- **server** — Hono HTTP API, BullMQ workers, SSE, RBAC.
- **dashboard** — Next.js App Router web UI.
- **cli** — Commander.js CLI.

**Rules:**
- All shared domain types MUST be defined in `packages/core/src/types.ts` and imported from `@snoutguard/core`.
- Cross-package dependencies MUST use `@snoutguard/` scoped names, never relative paths.
- Each package MUST export its public API through an `index.ts` barrel file.
- `@snoutguard/core` MUST NOT depend on any other `@snoutguard/*` package.
- Downstream packages MUST import Drizzle operators from `@snoutguard/core`, not `drizzle-orm` directly.
- New domain capabilities should be new packages, not bolted onto existing ones.

## LLM Layer (Anthropic Claude)

All LLM operations use Anthropic Claude exclusively via `core/src/llm.ts`. Different models per operation (Opus for analysis, Sonnet for review/MCP/summary). Built-in cost tracking, caching with TTL, retry with exponential backoff, and context window overflow prevention.

**Rules:**
- All LLM calls MUST go through `analyzeWithLlm` or `analyzeWithLlmValidated` — never use the SDK directly.
- New LLM operations MUST be added to the `LlmOperation` type and model mapping.
- Cost tracking is mandatory — every call updates the run cost accumulator.
- Cost limits (`maxCostPerRun`) MUST be respected; exceeding throws `LlmCostLimitError`.
- All structured LLM responses MUST be validated against Zod schemas via `analyzeWithLlmValidated`.
- All LLM prompts MUST use XML-tagged sections (`<role>`, `<task>`, `<output_format>`, etc.) following Anthropic best practices.
- Few-shot examples SHOULD be included for complex extraction tasks.
- All LLM failures MUST throw specific `LlmError` subclasses (`LlmAuthError`, `LlmRateLimitError`, `LlmValidationError`, `LlmCostLimitError`), never generic `Error`.
- JSON extraction handles markdown fences and truncated responses via `repairTruncatedJson`.

## Database (SQLite + Drizzle ORM)

SQLite via `better-sqlite3` with Drizzle ORM. Schema in `core/src/db/schema.ts` (16 tables). WAL mode enabled.

**Rules:**
- All database interactions MUST go through Drizzle ORM query builders — no raw SQL in application code.
- Schema changes require updating Drizzle schema definitions in `core/src/db/schema.ts`.
- JSON/array fields are stored as text — serialize with `JSON.stringify`, parse with `JSON.parse`.
- Database initialization MUST be lazy via `initializeDatabase()`.
- Repository deletion MUST cascade in dependency order: evidence → decisions, drift_events → snapshots, dependencies, reviews, sync_history → repository.

## Server (Hono + BullMQ)

HTTP framework is Hono. Routes are factory functions accepting `DbClient`, returning Hono routers. Middleware chain: CORS → logger → auth → org-context → rate-limit → routes.

**Rules:**
- All route modules MUST export a `createXxxRouter(db: DbClient)` factory function.
- Route handlers receive Hono `Context` objects — this is NOT Express.
- Webhook and health routes MUST be mounted before the auth middleware chain.
- Long-running operations MUST be processed via BullMQ queues, never inline in HTTP handlers.
- Redis is required for the server (`REDIS_URL` env var). Workers can be disabled via `ENABLE_WORKERS=false`.
- Heavy package imports in job processors MUST use dynamic `import()` to avoid circular dependencies.
- Real-time updates MUST use Server-Sent Events (SSE), not WebSockets or polling.
- SSE events MUST be scoped to the user's organization.

## Security & Multi-Tenancy

4-tier RBAC: owner > admin > member > viewer. Permissions follow `resource:action` pattern. Multi-tenant with org-scoped data isolation.

**Rules:**
- Every API route MUST use `requirePermission()` or `requireRole()` middleware.
- New permissions MUST be added to `ROLE_PERMISSIONS` in `core/auth.ts`.
- ALL database queries MUST be scoped to the authenticated user's `orgId`.
- `orgId` MUST come from the authenticated session, NEVER from user input.
- Auth can be disabled for local/CLI mode via `SNOUTGUARD_DISABLE_AUTH` env var.
- Rate limiting: `analysisLimit` for expensive ops, `strictLimit` for auth, `standardLimit` for general API.
- Webhook endpoints MUST verify cryptographic signatures (HMAC-SHA256 with constant-time comparison).
- In-memory session store is dev-only — production requires Redis.

## Dashboard (Next.js)

Next.js App Router with route groups: `(auth)` for login/signup/SSO, `(app)` for authenticated pages. Tailwind CSS with custom `brand-*` color palette. Recharts for visualization.

**Rules:**
- Authenticated pages MUST be under `(app)/` route group; auth pages under `(auth)/`.
- All pages use `'use client'` directive.
- All API calls MUST go through `lib/api.ts` (`apiFetch`, `apiGet`, `apiPost`, etc.) — never raw `fetch`.
- Data fetching MUST be encapsulated in custom hooks under `hooks/` returning `{ data, loading, error }`.
- No external state management libraries (no Redux, Zustand, React Query, SWR).
- Conditional class composition MUST use the `cn()` utility (clsx + tailwind-merge).
- Components are organized by domain (`decisions/`, `reviews/`, `velocity/`), not by type.
- Charts MUST use Recharts wrapped in `ResponsiveContainer` with empty state handling.

## CLI (Commander.js)

12 subcommands, each in its own file under `commands/`, exporting `registerXxxCommand(program)`.

**Rules:**
- Each command MUST be in its own file under `commands/` exporting `registerXxxCommand`.
- Commands MUST use `chalk` for colors, `ora` for spinners, and tapir-themed branding.
- Commands MUST load config via `loadConfig()` from `@snoutguard/core`.
- Commands requiring LLM MUST validate API key upfront with `requireApiKey()`.

## Analyzer & Reviewer

The analyzer uses regex-based multi-language parsing (TS, JS, Python, Go, Rust, Java), tiered file content strategy (score ≥ 4 = full content, else summary), batched LLM calls with bounded parallelism, and incremental analysis via file-hash caching.

The reviewer runs a dual pipeline: deterministic rule engine first, then LLM review. Results are merged with rule-based violations taking precedence.

**Rules:**
- Rule-based violations ALWAYS take precedence over LLM violations when they overlap.
- New deterministic checks go in the rule engine, not the LLM reviewer.
- Files scoring ≥ 4 get full content sent to LLM; others get structural summaries only.
- Token budget per batch MUST NOT exceed `MAX_TOKENS_PER_BATCH` (100K).
- Cache is invalidated by SHA-256 content hash mismatch; `--force` bypasses all caching.
- Dependency analysis MUST calculate all five Robert C. Martin metrics (Ca, Ce, I, A, D).

## Context Sync

Generates AI assistant context files in 7+ formats. Each generator in `generators/` accepts `(decisions, config)` → `string`.

**Rules:**
- New formats require a new generator file, a `SyncFormat` enum value, and entries in `getOutputPath`/`renderFormat`.
- Generated files MUST include `<!-- snoutguard:user-start/end -->` markers.
- User sections between markers MUST be preserved across regeneration.
- Shared template helpers MUST be registered in `templates.ts`.

## MCP Server

Exposes architectural knowledge via Model Context Protocol. Tools: `get_architectural_decisions`, `check_architectural_compliance`, `get_architectural_guidance`, `get_dependencies`. Resources use `snoutguard://` URI scheme.

**Rules:**
- MCP tools MUST have Zod input schemas and return `{ content: [{ type: 'text', text: ... }] }`.
- Resources MUST use the `snoutguard://` URI scheme.
- All three transports (stdio, SSE, streamable HTTP) MUST be supported.

## Integrations

GitHub, Bitbucket, Slack each follow parallel patterns: `api.ts` (client), `pr-bot.ts` (PR logic), `webhook.ts` (event routing).

**Rules:**
- New platform integrations MUST follow the `api.ts` + `pr-bot.ts` + `webhook.ts` pattern.
- Each platform MUST have a corresponding formatter in `reviewer/src/formatters/`.
- All formatters accept the same `ReviewResult` input.
- Use factory functions (`createGitHubClient`, `createSlackApp`), not classes.

## Code Style

- Prefer factory functions over classes for business logic.
- Classes are reserved for stateful infrastructure (Logger, SyncEngine, SummaryScheduler) and error types.
- Use TypeScript union types, not enums, for enum-like values.
- External data sources MUST be abstracted behind provider interfaces with `isAvailable()` and no-op defaults.
- Logger MUST be initialized via `initLogger()` at CLI startup; library code uses `getLogger()`.

## Workflow

- Before writing code, if `get_architectural_guidance` MCP tool is available, call it with a description of the task to get relevant constraints. If MCP is not configured, review the constraints in this file that relate to the files being modified.
- After making changes, run `snoutguard review --diff <branch>` to check for architectural violations before committing.
- After significant refactors or new features, run `snoutguard analyze` then `snoutguard sync` to keep this context file current (incremental — only re-analyzes changed files).

<!-- snoutguard:user-start -->` / `<!-- snoutguard:user-end -->
