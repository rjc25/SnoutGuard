/**
 * Generator for .github/copilot-instructions.md files.
 * Produces markdown optimized for GitHub Copilot's instruction format.
 * Copilot reads this file from .github/copilot-instructions.md to guide code generation.
 */

import type { ArchDecision, ArchGuardConfig } from '@archguard/core';
import {
  groupByCategory,
  activeDecisions,
  sortByConfidence,
  getAllConstraints,
} from '../templates.js';

/**
 * Generate a .github/copilot-instructions.md file from architectural decisions.
 *
 * GitHub Copilot uses this file for repository-level custom instructions.
 * The format is concise markdown with clear directives that Copilot can
 * apply during code completion and chat interactions.
 */
export function generateCopilotInstructions(
  decisions: ArchDecision[],
  config: ArchGuardConfig
): string {
  const active = sortByConfidence(activeDecisions(decisions));
  const grouped = groupByCategory(active);
  const constraints = getAllConstraints(active);

  const lines: string[] = [];

  // ── Header ──────────────────────────────────────────────────────
  lines.push('# Copilot Instructions');
  lines.push('');
  lines.push(`<!-- Generated by ArchGuard on ${new Date().toISOString()} -->`);
  lines.push('<!-- Do not edit generated sections. Use the user section markers for custom content. -->');
  lines.push('');

  // ── Project Overview ────────────────────────────────────────────
  lines.push('## Project Overview');
  lines.push('');
  lines.push(`This is a ${config.analysis.languages.join('/')} project with ${active.length} established architectural decisions.`);
  lines.push('');

  // ── Code Generation Rules ───────────────────────────────────────
  lines.push('## Code Generation Rules');
  lines.push('');
  lines.push('When generating code for this project, follow these rules:');
  lines.push('');

  let ruleNum = 1;
  for (const decision of active) {
    lines.push(`${ruleNum}. **${decision.title}**: ${decision.description}`);
    ruleNum++;
  }
  lines.push('');

  // ── Constraints ─────────────────────────────────────────────────
  if (constraints.length > 0) {
    lines.push('## Constraints');
    lines.push('');
    lines.push('Always respect these constraints:');
    lines.push('');
    for (const constraint of constraints) {
      lines.push(`- ${constraint}`);
    }
    lines.push('');
  }

  // ── Patterns ────────────────────────────────────────────────────
  lines.push('## Patterns');
  lines.push('');

  const categoryLabels: Record<string, string> = {
    structural: 'Project Structure',
    behavioral: 'Behavioral Patterns',
    deployment: 'Deployment',
    data: 'Data Layer',
    api: 'API Design',
    testing: 'Testing',
    security: 'Security',
  };

  for (const [category, categoryDecisions] of Object.entries(grouped)) {
    const label = categoryLabels[category] ?? category;
    lines.push(`### ${label}`);
    lines.push('');

    for (const decision of categoryDecisions) {
      lines.push(`- **${decision.title}**: ${decision.description}`);

      // Include a brief code snippet if evidence has one
      const snippetEvidence = decision.evidence.find((ev: { snippet: string }) => ev.snippet.length > 0);
      if (snippetEvidence) {
        lines.push(`  - See: \`${snippetEvidence.filePath}\` - ${snippetEvidence.explanation}`);
      }
    }
    lines.push('');
  }

  // ── Custom Rules ────────────────────────────────────────────────
  if (config.rules.length > 0) {
    lines.push('## Custom Rules');
    lines.push('');
    for (const rule of config.rules) {
      lines.push(`- **${rule.name}** (${rule.severity}): pattern \`${rule.pattern}\``);
      if (rule.allowedIn && rule.allowedIn.length > 0) {
        lines.push(`  - Allowed in: ${rule.allowedIn.join(', ')}`);
      }
      if (rule.notAllowedIn && rule.notAllowedIn.length > 0) {
        lines.push(`  - Not allowed in: ${rule.notAllowedIn.join(', ')}`);
      }
    }
    lines.push('');
  }

  // ── Style Guide ─────────────────────────────────────────────────
  lines.push('## Style Guide');
  lines.push('');
  lines.push('When completing code:');
  lines.push('');
  lines.push('- Follow existing patterns in the codebase over general best practices.');
  lines.push('- Match the naming conventions visible in the existing code.');
  lines.push('- Maintain consistent import styles with the rest of the project.');
  lines.push('- Prefer the libraries and frameworks already in use.');
  lines.push('');

  // ── Key Reference Files ─────────────────────────────────────────
  const allFiles = new Set<string>();
  for (const d of active) {
    for (const ev of d.evidence) {
      allFiles.add(ev.filePath);
    }
  }

  if (allFiles.size > 0) {
    lines.push('## Reference Files');
    lines.push('');
    lines.push('These files demonstrate the expected patterns:');
    lines.push('');
    for (const file of Array.from(allFiles).sort().slice(0, 15)) {
      lines.push(`- \`${file}\``);
    }
    if (allFiles.size > 15) {
      lines.push(`- ...and ${allFiles.size - 15} more`);
    }
    lines.push('');
  }

  return lines.join('\n');
}
