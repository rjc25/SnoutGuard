/**
 * Generator for .cursorrules files.
 * Produces structured text optimized for Cursor AI's context understanding.
 * The .cursorrules format uses plain text with clear section headers.
 */

import type { ArchDecision, ArchGuardConfig } from '@archguard/core';
import {
  groupByCategory,
  activeDecisions,
  sortByConfidence,
  getAllConstraints,
  getAllTags,
} from '../templates.js';

/**
 * Generate a .cursorrules file from architectural decisions.
 *
 * The output is structured text with sections:
 * - Project Architecture overview
 * - Architectural Patterns (grouped by category)
 * - Constraints & Rules
 * - Code Style & Conventions
 * - Key Files & Evidence
 */
export function generateCursorRules(
  decisions: ArchDecision[],
  config: ArchGuardConfig
): string {
  const active = sortByConfidence(activeDecisions(decisions));
  const grouped = groupByCategory(active);
  const constraints = getAllConstraints(active);
  const tags = getAllTags(active);

  const lines: string[] = [];

  // ── Header ──────────────────────────────────────────────────────
  lines.push('# Project Architecture Rules');
  lines.push(`# Generated by ArchGuard (https://github.com/rjc25/ArchGuard) — ${new Date().toISOString()}`);
  lines.push('# Do not edit the generated sections. Add custom rules below the user section markers.');
  lines.push('');

  // ── Architecture Overview ───────────────────────────────────────
  lines.push('## Architecture Overview');
  lines.push('');
  lines.push(`Languages: ${config.analysis.languages.join(', ')}`);
  lines.push(`Total architectural decisions: ${active.length}`);
  lines.push(`Categories covered: ${Object.keys(grouped).join(', ')}`);
  if (tags.length > 0) {
    lines.push(`Tags: ${tags.join(', ')}`);
  }
  lines.push('');

  // ── Patterns by Category ────────────────────────────────────────
  lines.push('## Architectural Patterns');
  lines.push('');

  const categoryLabels: Record<string, string> = {
    structural: 'Structural Architecture',
    behavioral: 'Behavioral Patterns',
    deployment: 'Deployment & Infrastructure',
    data: 'Data Architecture',
    api: 'API Design',
    testing: 'Testing Strategy',
    security: 'Security Architecture',
  };

  for (const [category, categoryDecisions] of Object.entries(grouped)) {
    const label = categoryLabels[category] ?? category;
    lines.push(`### ${label}`);
    lines.push('');

    for (const decision of categoryDecisions) {
      const statusLabel = decision.status === 'confirmed' ? 'CONFIRMED' : decision.status.toUpperCase();
      lines.push(`- **${decision.title}** [${statusLabel}] (confidence: ${Math.round(decision.confidence * 100)}%)`);
      lines.push(`  ${decision.description}`);

      if (decision.tags.length > 0) {
        lines.push(`  Tags: ${decision.tags.join(', ')}`);
      }

      if (decision.evidence.length > 0) {
        lines.push(`  Evidence:`);
        for (const ev of decision.evidence.slice(0, 3)) {
          lines.push(`    - ${ev.filePath}:${ev.lineRange[0]}-${ev.lineRange[1]}: ${ev.explanation}`);
        }
        if (decision.evidence.length > 3) {
          lines.push(`    - ... and ${decision.evidence.length - 3} more`);
        }
      }

      lines.push('');
    }
  }

  // ── Constraints ─────────────────────────────────────────────────
  lines.push('## Constraints & Rules');
  lines.push('');
  lines.push('When writing or modifying code, always respect these constraints:');
  lines.push('');

  if (constraints.length > 0) {
    for (const constraint of constraints) {
      lines.push(`- ${constraint}`);
    }
  } else {
    lines.push('No explicit constraints defined.');
  }
  lines.push('');

  // ── Custom Rules from Config ────────────────────────────────────
  if (config.rules.length > 0) {
    lines.push('## Custom Rules');
    lines.push('');
    for (const rule of config.rules) {
      lines.push(`- **${rule.name}** [${rule.severity.toUpperCase()}]: pattern \`${rule.pattern}\``);
      if (rule.allowedIn && rule.allowedIn.length > 0) {
        lines.push(`  Allowed in: ${rule.allowedIn.join(', ')}`);
      }
      if (rule.notAllowedIn && rule.notAllowedIn.length > 0) {
        lines.push(`  Not allowed in: ${rule.notAllowedIn.join(', ')}`);
      }
    }
    lines.push('');
  }

  // ── Code Style Guidance ─────────────────────────────────────────
  lines.push('## Code Style & Conventions');
  lines.push('');
  lines.push('Follow the established patterns in this codebase:');
  lines.push('');

  const structuralDecisions = grouped['structural'] ?? [];
  const behavioralDecisions = grouped['behavioral'] ?? [];
  const apiDecisions = grouped['api'] ?? [];

  if (structuralDecisions.length > 0) {
    lines.push('### Project Structure');
    for (const d of structuralDecisions) {
      lines.push(`- ${d.title}: ${d.description}`);
    }
    lines.push('');
  }

  if (behavioralDecisions.length > 0) {
    lines.push('### Behavioral Patterns');
    for (const d of behavioralDecisions) {
      lines.push(`- ${d.title}: ${d.description}`);
    }
    lines.push('');
  }

  if (apiDecisions.length > 0) {
    lines.push('### API Conventions');
    for (const d of apiDecisions) {
      lines.push(`- ${d.title}: ${d.description}`);
    }
    lines.push('');
  }

  // ── Key Evidence Files ──────────────────────────────────────────
  const allFiles = new Set<string>();
  for (const d of active) {
    for (const ev of d.evidence) {
      allFiles.add(ev.filePath);
    }
  }

  if (allFiles.size > 0) {
    lines.push('## Key Architecture Files');
    lines.push('');
    lines.push('These files contain important architectural patterns:');
    lines.push('');
    for (const file of Array.from(allFiles).sort().slice(0, 20)) {
      lines.push(`- ${file}`);
    }
    if (allFiles.size > 20) {
      lines.push(`- ... and ${allFiles.size - 20} more files`);
    }
    lines.push('');
  }

  return lines.join('\n');
}
