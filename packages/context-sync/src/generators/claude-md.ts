/**
 * Generator for CLAUDE.md files.
 * Produces markdown optimized for Claude Code's project context understanding.
 * CLAUDE.md is read automatically by Claude Code when working in a repository.
 */

import type { ArchDecision, ArchGuardConfig } from '@archguard/core';
import {
  groupByCategory,
  activeDecisions,
  sortByConfidence,
  getAllConstraints,
  getAllTags,
} from '../templates.js';

/**
 * Generate a CLAUDE.md file from architectural decisions.
 *
 * The output is markdown with sections:
 * - # Architecture (top-level overview)
 * - ## Decisions (grouped by category with details)
 * - ## Constraints (all constraints as imperative rules)
 * - ## Patterns (code patterns to follow)
 * - ## Key Files (important architecture files)
 */
export function generateClaudeMd(
  decisions: ArchDecision[],
  config: ArchGuardConfig
): string {
  const active = sortByConfidence(activeDecisions(decisions));
  const grouped = groupByCategory(active);
  const constraints = getAllConstraints(active);
  const tags = getAllTags(active);

  const lines: string[] = [];

  // ── Header ──────────────────────────────────────────────────────
  lines.push('# Architecture');
  lines.push('');
  lines.push(`> Generated by [ArchGuard](https://github.com/rjc25/ArchGuard) on ${new Date().toISOString()}`);
  lines.push('> Do not edit generated sections. Use the user section markers for custom content.');
  lines.push('');
  lines.push(`This project uses ${config.analysis.languages.join(', ')} with ${active.length} documented architectural decisions.`);
  lines.push('');

  // ── Decisions ───────────────────────────────────────────────────
  lines.push('## Decisions');
  lines.push('');

  const categoryLabels: Record<string, string> = {
    structural: 'Structural Architecture',
    behavioral: 'Behavioral Patterns',
    deployment: 'Deployment & Infrastructure',
    data: 'Data Architecture',
    api: 'API Design',
    testing: 'Testing Strategy',
    security: 'Security Architecture',
  };

  for (const [category, categoryDecisions] of Object.entries(grouped)) {
    const label = categoryLabels[category] ?? category;
    lines.push(`### ${label}`);
    lines.push('');

    for (const decision of categoryDecisions) {
      const status = decision.status.toUpperCase();
      const confidence = Math.round(decision.confidence * 100);
      lines.push(`**${decision.title}** \`${status}\` (${confidence}% confidence)`);
      lines.push('');
      lines.push(decision.description);
      lines.push('');

      if (decision.constraints.length > 0) {
        lines.push('Constraints:');
        for (const constraint of decision.constraints) {
          lines.push(`- ${constraint}`);
        }
        lines.push('');
      }

      if (decision.evidence.length > 0) {
        lines.push('Evidence:');
        for (const ev of decision.evidence.slice(0, 3)) {
          lines.push(`- \`${ev.filePath}:${ev.lineRange[0]}-${ev.lineRange[1]}\` - ${ev.explanation}`);
        }
        if (decision.evidence.length > 3) {
          lines.push(`- ...and ${decision.evidence.length - 3} more locations`);
        }
        lines.push('');
      }

      if (decision.tags.length > 0) {
        lines.push(`Tags: ${decision.tags.map((t: string) => `\`${t}\``).join(', ')}`);
        lines.push('');
      }
    }
  }

  // ── Constraints ─────────────────────────────────────────────────
  lines.push('## Constraints');
  lines.push('');
  lines.push('When writing or modifying code in this project, you MUST follow these constraints:');
  lines.push('');

  if (constraints.length > 0) {
    for (const constraint of constraints) {
      lines.push(`- ${constraint}`);
    }
  } else {
    lines.push('No explicit constraints defined yet.');
  }
  lines.push('');

  // ── Custom Rules ────────────────────────────────────────────────
  if (config.rules.length > 0) {
    lines.push('### Custom Rules');
    lines.push('');
    lines.push('| Rule | Severity | Pattern | Scope |');
    lines.push('|------|----------|---------|-------|');
    for (const rule of config.rules) {
      const scope = rule.allowedIn
        ? `Allowed in: ${rule.allowedIn.join(', ')}`
        : rule.notAllowedIn
          ? `Not in: ${rule.notAllowedIn.join(', ')}`
          : 'Global';
      lines.push(`| ${rule.name} | ${rule.severity} | \`${rule.pattern}\` | ${scope} |`);
    }
    lines.push('');
  }

  // ── Patterns ────────────────────────────────────────────────────
  lines.push('## Patterns');
  lines.push('');
  lines.push('Follow these established patterns when contributing to this codebase:');
  lines.push('');

  for (const [category, categoryDecisions] of Object.entries(grouped)) {
    const label = categoryLabels[category] ?? category;
    lines.push(`### ${label}`);
    lines.push('');
    for (const d of categoryDecisions) {
      lines.push(`- **${d.title}**: ${d.description}`);
    }
    lines.push('');
  }

  // ── Key Files ───────────────────────────────────────────────────
  const allFiles = new Set<string>();
  for (const d of active) {
    for (const ev of d.evidence) {
      allFiles.add(ev.filePath);
    }
  }

  if (allFiles.size > 0) {
    lines.push('## Key Files');
    lines.push('');
    lines.push('These files embody important architectural patterns. Study them before making changes:');
    lines.push('');
    for (const file of Array.from(allFiles).sort().slice(0, 25)) {
      lines.push(`- \`${file}\``);
    }
    if (allFiles.size > 25) {
      lines.push(`- ...and ${allFiles.size - 25} more files`);
    }
    lines.push('');
  }

  // ── Tags ────────────────────────────────────────────────────────
  if (tags.length > 0) {
    lines.push('## Tags');
    lines.push('');
    lines.push(tags.map((t) => `\`${t}\``).join(' '));
    lines.push('');
  }

  return lines.join('\n');
}
