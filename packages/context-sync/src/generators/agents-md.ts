/**
 * Generator for agents.md files.
 * Produces markdown formatted as agent instructions, suitable for
 * tools that support an agents.md convention for AI assistant behavior.
 */

import type { ArchDecision, ArchGuardConfig } from '@archguard/core';
import {
  groupByCategory,
  activeDecisions,
  sortByConfidence,
  getAllConstraints,
} from '../templates.js';

/**
 * Generate an agents.md file from architectural decisions.
 *
 * The output uses an agent-instruction format with:
 * - Identity and role preamble
 * - Architectural rules as imperative instructions
 * - Pattern guidelines grouped by concern
 * - Constraint enforcement instructions
 */
export function generateAgentsMd(
  decisions: ArchDecision[],
  config: ArchGuardConfig
): string {
  const active = sortByConfidence(activeDecisions(decisions));
  const grouped = groupByCategory(active);
  const constraints = getAllConstraints(active);

  const lines: string[] = [];

  // ── Header ──────────────────────────────────────────────────────
  lines.push('# Agent Instructions');
  lines.push('');
  lines.push(`> Generated by ArchGuard on ${new Date().toISOString()}`);
  lines.push('> Do not edit generated sections. Use the user section markers for custom content.');
  lines.push('');

  // ── Role & Context ──────────────────────────────────────────────
  lines.push('## Role');
  lines.push('');
  lines.push('You are an AI coding assistant working on this project. You must follow the');
  lines.push('architectural decisions, patterns, and constraints documented below. These rules');
  lines.push('were extracted from the actual codebase and represent established conventions.');
  lines.push('');

  // ── Project Context ─────────────────────────────────────────────
  lines.push('## Project Context');
  lines.push('');
  lines.push(`- **Languages**: ${config.analysis.languages.join(', ')}`);
  lines.push(`- **Architectural decisions**: ${active.length}`);
  lines.push(`- **Source patterns**: ${config.analysis.include.join(', ')}`);
  lines.push('');

  // ── Architectural Rules ─────────────────────────────────────────
  lines.push('## Architectural Rules');
  lines.push('');
  lines.push('You MUST follow these rules when generating or modifying code:');
  lines.push('');

  const categoryLabels: Record<string, string> = {
    structural: 'Structure',
    behavioral: 'Behavior',
    deployment: 'Deployment',
    data: 'Data',
    api: 'API',
    testing: 'Testing',
    security: 'Security',
  };

  let ruleNum = 1;
  for (const decision of active) {
    const catLabel = categoryLabels[decision.category] ?? decision.category;
    lines.push(`${ruleNum}. **[${catLabel}] ${decision.title}**: ${decision.description}`);
    ruleNum++;
  }
  lines.push('');

  // ── Patterns by Category ────────────────────────────────────────
  lines.push('## Patterns');
  lines.push('');
  lines.push('When writing code, apply these patterns based on the area of change:');
  lines.push('');

  for (const [category, categoryDecisions] of Object.entries(grouped)) {
    const label = categoryLabels[category] ?? category;
    lines.push(`### ${label}`);
    lines.push('');

    for (const decision of categoryDecisions) {
      const confidence = Math.round(decision.confidence * 100);
      lines.push(`#### ${decision.title} (${confidence}% confidence)`);
      lines.push('');
      lines.push(decision.description);
      lines.push('');

      if (decision.evidence.length > 0) {
        lines.push('Reference files:');
        for (const ev of decision.evidence.slice(0, 3)) {
          lines.push(`- \`${ev.filePath}\`: ${ev.explanation}`);
        }
        lines.push('');
      }
    }
  }

  // ── Constraints ─────────────────────────────────────────────────
  lines.push('## Constraints');
  lines.push('');
  lines.push('These constraints are mandatory. Do NOT violate them:');
  lines.push('');

  if (constraints.length > 0) {
    for (const constraint of constraints) {
      lines.push(`- [ ] ${constraint}`);
    }
  } else {
    lines.push('No explicit constraints defined.');
  }
  lines.push('');

  // ── Custom Rules ────────────────────────────────────────────────
  if (config.rules.length > 0) {
    lines.push('## Custom Rules');
    lines.push('');
    lines.push('Enforce these additional rules:');
    lines.push('');
    for (const rule of config.rules) {
      lines.push(`- **${rule.name}** [${rule.severity.toUpperCase()}]: Matches pattern \`${rule.pattern}\``);
      if (rule.allowedIn) {
        lines.push(`  - Only allowed in: ${rule.allowedIn.join(', ')}`);
      }
      if (rule.notAllowedIn) {
        lines.push(`  - Not allowed in: ${rule.notAllowedIn.join(', ')}`);
      }
    }
    lines.push('');
  }

  // ── Behavioral Guidelines ───────────────────────────────────────
  lines.push('## Behavioral Guidelines');
  lines.push('');
  lines.push('When assisting with this project:');
  lines.push('');
  lines.push('1. Always check if a change aligns with the architectural decisions above.');
  lines.push('2. If a proposed change conflicts with an established pattern, flag it and explain the conflict.');
  lines.push('3. Suggest refactoring approaches that maintain architectural consistency.');
  lines.push('4. When creating new files, follow the established project structure.');
  lines.push('5. Preserve existing patterns even when the user does not explicitly request it.');
  lines.push('');

  return lines.join('\n');
}
