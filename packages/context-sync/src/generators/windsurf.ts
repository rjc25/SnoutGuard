/**
 * Generator for .windsurfrules files.
 * Produces structured text optimized for Windsurf (Codeium) AI's context format.
 * The .windsurfrules file lives at the project root and guides Windsurf's Cascade AI.
 */

import type { ArchDecision, ArchGuardConfig } from '@archguard/core';
import {
  groupByCategory,
  activeDecisions,
  sortByConfidence,
  getAllConstraints,
  getAllTags,
} from '../templates.js';

/**
 * Generate a .windsurfrules file from architectural decisions.
 *
 * Windsurf uses a plain-text rules format similar to .cursorrules but
 * with its own conventions. The output emphasizes clear directives and
 * structured sections that Windsurf's Cascade AI can parse effectively.
 */
export function generateWindsurfRules(
  decisions: ArchDecision[],
  config: ArchGuardConfig
): string {
  const active = sortByConfidence(activeDecisions(decisions));
  const grouped = groupByCategory(active);
  const constraints = getAllConstraints(active);
  const tags = getAllTags(active);

  const lines: string[] = [];

  // ── Header ──────────────────────────────────────────────────────
  lines.push('# Windsurf Rules');
  lines.push(`# Generated by ArchGuard — ${new Date().toISOString()}`);
  lines.push('# Do not edit generated sections. Use the user section markers for custom content.');
  lines.push('');

  // ── Project Identity ────────────────────────────────────────────
  lines.push('## Project');
  lines.push('');
  lines.push(`Languages: ${config.analysis.languages.join(', ')}`);
  lines.push(`Decisions: ${active.length}`);
  if (tags.length > 0) {
    lines.push(`Tags: ${tags.join(', ')}`);
  }
  lines.push('');

  // ── Rules ───────────────────────────────────────────────────────
  lines.push('## Rules');
  lines.push('');
  lines.push('Follow these architectural rules at all times:');
  lines.push('');

  for (const decision of active) {
    const confidence = Math.round(decision.confidence * 100);
    lines.push(`### ${decision.title}`);
    lines.push(`Status: ${decision.status.toUpperCase()} | Confidence: ${confidence}%`);
    lines.push(`Category: ${decision.category}`);
    lines.push('');
    lines.push(decision.description);
    lines.push('');

    if (decision.constraints.length > 0) {
      lines.push('Constraints:');
      for (const constraint of decision.constraints) {
        lines.push(`  - ${constraint}`);
      }
      lines.push('');
    }

    if (decision.evidence.length > 0) {
      lines.push('Reference:');
      for (const ev of decision.evidence.slice(0, 2)) {
        lines.push(`  - ${ev.filePath}: ${ev.explanation}`);
      }
      lines.push('');
    }
  }

  // ── Constraints ─────────────────────────────────────────────────
  lines.push('## Constraints');
  lines.push('');
  lines.push('These constraints must not be violated:');
  lines.push('');

  if (constraints.length > 0) {
    for (const constraint of constraints) {
      lines.push(`- ${constraint}`);
    }
  } else {
    lines.push('No explicit constraints defined.');
  }
  lines.push('');

  // ── Custom Rules ────────────────────────────────────────────────
  if (config.rules.length > 0) {
    lines.push('## Custom Rules');
    lines.push('');
    for (const rule of config.rules) {
      lines.push(`- ${rule.name} [${rule.severity.toUpperCase()}]`);
      lines.push(`  Pattern: ${rule.pattern}`);
      if (rule.allowedIn && rule.allowedIn.length > 0) {
        lines.push(`  Allowed in: ${rule.allowedIn.join(', ')}`);
      }
      if (rule.notAllowedIn && rule.notAllowedIn.length > 0) {
        lines.push(`  Not allowed in: ${rule.notAllowedIn.join(', ')}`);
      }
    }
    lines.push('');
  }

  // ── Patterns ────────────────────────────────────────────────────
  lines.push('## Coding Patterns');
  lines.push('');

  const categoryLabels: Record<string, string> = {
    structural: 'Structure',
    behavioral: 'Behavior',
    deployment: 'Deployment',
    data: 'Data',
    api: 'API',
    testing: 'Testing',
    security: 'Security',
  };

  for (const [category, categoryDecisions] of Object.entries(grouped)) {
    const label = categoryLabels[category] ?? category;
    lines.push(`### ${label}`);
    for (const d of categoryDecisions) {
      lines.push(`- ${d.title}: ${d.description}`);
    }
    lines.push('');
  }

  // ── Key Files ───────────────────────────────────────────────────
  const allFiles = new Set<string>();
  for (const d of active) {
    for (const ev of d.evidence) {
      allFiles.add(ev.filePath);
    }
  }

  if (allFiles.size > 0) {
    lines.push('## Key Files');
    lines.push('');
    for (const file of Array.from(allFiles).sort().slice(0, 15)) {
      lines.push(`- ${file}`);
    }
    if (allFiles.size > 15) {
      lines.push(`- ... and ${allFiles.size - 15} more`);
    }
    lines.push('');
  }

  return lines.join('\n');
}
